<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>ETERNAL â€” Payment</title>
  <style>
    :root { color-scheme: dark; }
    * { box-sizing: border-box; }

    body {
      margin: 0; padding: 0;
      background: #000; color: #fff;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      line-height: 1.45;
    }

    .wrap { max-width: 740px; margin: 0 auto; padding: 28px 18px 40px; }

    .head { text-align: center; margin-bottom: 6px; }
    .head h1{
      font-size: 30px;
      letter-spacing: 0.08em;
      padding-left: 0.08em;
      margin: 0 0 10px;
      line-height: 1.1;
    }
    .head .small{
      opacity: 0.85;
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: 0.22em;
      padding-left: 0.22em;
    }

    .small { opacity: 0.85; font-size: 13px; }

    .card {
      border: 1px solid rgba(255,255,255,0.18);
      border-radius: 14px;
      padding: 18px;
      margin-top: 18px;
      background: rgba(255,255,255,0.03);
      overflow: hidden;
    }

    .btn {
      appearance: none;
      border: 1px solid rgba(255,255,255,0.35);
      background: rgba(255,255,255,0.10);
      color: #fff;
      border-radius: 999px;
      padding: 14px 28px;
      font-size: 18px;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      min-width: 160px;
    }
    .btn:hover { background: rgba(255,255,255,0.14); }
    .btn:disabled { opacity: 0.45; cursor: not-allowed; }

    .row { display: flex; gap: 12px; flex-wrap: wrap; align-items: center; }

    .hr { height: 1px; background: rgba(255,255,255,0.14); margin: 16px 0; }
    a { color: rgba(255,255,255,0.85); }

    #payment-element {
      margin-top: 14px;
      max-width: 100%;
      overflow: hidden;
    }
    #payment-element * { max-width: 100%; }

    #err {
      margin-top: 12px;
      display: none;
      white-space: pre-wrap;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,70,70,0.45);
      color: rgba(255,255,255,0.95);
      background: rgba(255,70,70,0.10);
      font-size: 13px;
      opacity: 0.95;
    }

    @supports (-webkit-touch-callout: none) {
      .safari-hide { display: none !important; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="head">
      <h1>ETERNAL</h1>
      <div class="small">DARKFIELD</div>
    </div>

    <div class="card">
      <div class="small">Secure payment</div>
      <div style="margin-top:10px; font-size:22px;"><strong>US$1.99</strong></div>

      <div class="hr"></div>

      <div class="small">Enter your details</div>

      <form id="form">
        <div id="payment-element"></div>

        <div class="row" style="margin-top:16px;">
          <button class="btn" id="payBtn" type="submit" disabled>Pay</button>
          <a class="small" href="/">Cancel</a>
        </div>

        <div id="err"></div>
      </form>

      <p class="small safari-hide" style="margin-top:14px; opacity:0.7;">
        You will be returned to ETERNAL automatically after payment.
      </p>
    </div>
  </div>

  <script src="https://js.stripe.com/v3/"></script>
  <script>
    (async () => {
      const errBox = document.getElementById("err");
      const payBtn = document.getElementById("payBtn");
      const form = document.getElementById("form");

      function showErr(msg) {
        errBox.style.display = "block";
        errBox.textContent = msg;
      }
      function clearErr() {
        errBox.style.display = "none";
        errBox.textContent = "";
      }

      // 1) Get publishable key
      let pub;
      try {
        const cfgRes = await fetch("/api/config", { cache: "no-store" });
        const cfgText = await cfgRes.text();
        let cfg = {};
        try { cfg = JSON.parse(cfgText); } catch {}
        if (!cfgRes.ok) throw new Error(cfgText || `config ${cfgRes.status}`);
        pub = cfg.publishableKey;
        if (!pub) throw new Error("Missing publishableKey");
      } catch (e) {
        console.error(e);
        showErr("Missing Stripe configuration. Please try again later.");
        return;
      }

      // 2) Create PaymentIntent on your server
      let clientSecret, pi, claimSecret;
      try {
        const r = await fetch("/api/create-intent", { method: "POST", cache: "no-store" });
        const text = await r.text();
        let data = {};
        try { data = JSON.parse(text); } catch {}
        if (!r.ok) throw new Error(text || `create-intent ${r.status}`);
        clientSecret = data.clientSecret;
        pi = data.id;
        claimSecret = data.claimSecret;
        if (!clientSecret || !pi || !claimSecret) throw new Error("Bad intent response");
      } catch (e) {
        console.error(e);
        showErr("Could not start payment. Please refresh and try again.");
        return;
      }

      // 3) Mount Stripe Elements (dark / ritual)
      const stripe = Stripe(pub);

      const appearance = {
        theme: "night",
        variables: {
          colorBackground: "#000000",
          colorText: "#ffffff",
          colorDanger: "#ff4646",
          colorPrimary: "#cfcfcf",
          borderRadius: "14px",
          spacingUnit: "6px"
        },
        rules: {
          ".Input": {
            backgroundColor: "rgba(255,255,255,0.04)",
            border: "1px solid rgba(255,255,255,0.18)"
          },
          ".Label": { color: "rgba(255,255,255,0.8)" }
        }
      };

      const elements = stripe.elements({ clientSecret, appearance });

      // IMPORTANT: use supported options
      const paymentElement = elements.create("payment", {
        layout: { type: "tabs", defaultCollapsed: false },
        // Reduce friction: don't request address unless required by payment method
        billingDetails: "never"
      });

      paymentElement.mount("#payment-element");

      // Enable pay only when complete + surface validation errors
      let isComplete = false;
      paymentElement.on("change", (event) => {
        isComplete = !!event.complete;
        payBtn.disabled = !isComplete;
        if (event.error) showErr(event.error.message || "Please check your details.");
        else clearErr();
      });

      // Safety: allow pay if element never fires change (rare)
      setTimeout(() => { if (!isComplete) payBtn.disabled = false; }, 1500);

      // 4) Confirm payment
      form.addEventListener("submit", async (ev) => {
        ev.preventDefault();
        clearErr();
        payBtn.disabled = true;

        // IMPORTANT:
        // Use a URL fragment for the claim secret so it is NOT sent to the server (and is not logged),
        // and can be stripped immediately by index.html after claiming the device cookie.
        const return_url = `${location.origin}/?pi=${encodeURIComponent(pi)}#c=${encodeURIComponent(claimSecret)}`;

        const { error } = await stripe.confirmPayment({
          elements,
          confirmParams: { return_url }
        });

        if (error) {
          console.error(error);
          showErr(error.message || "Payment failed. Please try again.");
          payBtn.disabled = false;
        }
        // If no error, Stripe will usually redirect automatically.
      });
    })();
  </script>
</body>
</html>
